<!-- Update version below to match package.json version for cache busting -->
<script src="{% static "omero_autotag/js/bundle.min.js" %}?v=4.2.3"></script>

<script>

$(function() {
  var pluginIndex = {{ forloop.counter }};
  var url="{% url 'autotag_get_items' %}";
  var urlUpdate="{% url 'autotag_process_update' %}";
  var urlCreateTag="{% url 'autotag_create_tag' %}";

  var reactRender = function(datatree, selectedNodes, availableTypes, defaultType) {
    // Collect selected objects with their IDs
    var selectedObjects = [];
    var nodes = Array.isArray(selectedNodes) ? selectedNodes : [selectedNodes];

    nodes.forEach(function(node) {
      selectedObjects.push({
        id: node.data.obj.id,
        type: node.type,
        name: node.text
      });
    });

    // Collect children objects
    var childrenObjects = [];
    var processedIds = new Set();

    nodes.forEach(function(selectedNode) {
      selectedNode.children.forEach(function(childId) {
        var childNode = datatree.get_node(childId);

        // Skip non-image children of a tag
        if (selectedNode.type === "tag" && childNode.type !== "image") {
          return;
        }

        // Avoid duplicates
        if (!processedIds.has(childNode.data.obj.id)) {
          childrenObjects.push({
            id: childNode.data.obj.id,
            type: childNode.type,
            name: childNode.text
          });
          processedIds.add(childNode.data.obj.id);
        }
      });
    });

    // Call the autotagform with structured data
    autotagform.default(
      selectedObjects,
      childrenObjects,
      availableTypes,
      defaultType,
      url,
      urlUpdate,
      urlCreateTag
    );
  };

  $("#auto_tag_panel").omeroweb_center_plugin({
    plugin_index: pluginIndex,        // From the Django template loop
    empty_on_sel_change: false,       // Do not completely erase content when changing selection
    load_plugin_content: function(selected, dtype, oid) {

      // this may have been called before datatree was initialised...
      var datatree = $.jstree.reference('#dataTree');
      if (!datatree) return;

      // Get all selected items from the tree
      var tree_selected = datatree.get_selected(true);

      if (tree_selected === undefined || tree_selected.length === 0) {
        return;
      }

      console.log("AutoTag selected:", tree_selected);

      // Determine available types and default type based on selection
      var availableTypes = [];
      var defaultType = null;
      var hasImages = tree_selected.some(node => node.type === 'image');
      var hasDatasets = tree_selected.some(node => node.type === 'dataset');
      var hasProjects = tree_selected.some(node => node.type === 'project');
      var hasOrphaned = tree_selected.some(node => node.type === 'orphaned');
      var hasTags = tree_selected.some(node => node.type === 'tag');

      // Determine available item types based on selection
      if (hasProjects) {
        // Project selection: can tag Projects or Datasets
        availableTypes = ['Project', 'Dataset'];
        defaultType = 'Dataset';
      } else if (hasDatasets) {
        // Dataset selection: can tag Datasets or Images
        availableTypes = ['Dataset', 'Image'];
        defaultType = 'Image';
      } else if (hasImages) {
        // Image selection: can tag selected Images
        availableTypes = ['Image'];
        defaultType = 'Image';
      } else if (hasOrphaned) {
        // Orphaned selection: can only tag Images
        availableTypes = ['Image'];
        defaultType = 'Image';
      } else if (hasTags) {
        // Tag selection: can tag Projects, Datasets, or Images
        availableTypes = ['Project', 'Dataset', 'Image'];
        defaultType = 'Image';
      }

      // Ensure all selected nodes are loaded
      var nodesToLoad = [];
      tree_selected.forEach(function(node) {
        if (!datatree.is_loaded(node)) {
          nodesToLoad.push(node);
        }
      });

      if (nodesToLoad.length === 0) {
        // All nodes already loaded
        reactRender(datatree, tree_selected, availableTypes, defaultType);
      } else {
        // Load all unloaded nodes, then render
        var loadedCount = 0;
        var totalToLoad = nodesToLoad.length;

        var checkAllLoaded = function() {
          if (loadedCount === totalToLoad) {
            reactRender(datatree, tree_selected, availableTypes, defaultType);
          }
        };

        nodesToLoad.forEach(function(node) {
          datatree.load_node(node, function(loadedNode, status) {
            loadedCount++;
            checkAllLoaded();
          });
        });
      }
    },
    plugin_enabled: function(selected){
      // Required for multi-selection support
      // supported_obj_types only works for single selection
      if (selected.length == 0) return false;
      var dtype = selected[0]['id'].split('-')[0];
      if (selected.length > 1) {
          return ($.inArray(dtype, ["image", "dataset"]) > -1);
      } else {
          return ($.inArray(dtype, ["image", "dataset", "tag", "orphaned", "project"]) > -1);
      }
    }
  });
});

</script>
